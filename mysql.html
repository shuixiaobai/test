<!DOCTYPE html>
<html>
<head>
<title>MarkdownPad Document</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h2>                                   数据库，表，数据相关的操作</h2>
<hr />
<h2>数据库相关的SQL</h2>
<pre><code>1.查看所有数据库：  show databases;
2.创建数据库： create database 数据库名；
3.创建数据库时指定字符集：create database db2 character set gbk/utf8;
4.查看数据库详情：show create database 数据库名；
5.删除数据库：drop database 数据库名；
6.使用数据库：use 数据库名
</code></pre>

<h2>表相关的SQL</h2>
<pre><code>1.创建表
    -格式：create table 表名（字段1名 字段1类型，字段2名 字段2类型）;
        create table person(name varchar(10),age int);
2.查看所有表
    -格式：show tables;
3.查看表详情
    -格式：show create table 表名；   
        show create table person;
    -引擎：innodb:支持数据库高级操作  myisam:不支持数据库高级操作
4.创建表指定引擎和字符集
    -格式：create table 表名（字段1名 字段1类型）engine=myisam charset=gbk;
    create table t1(name varchar(10),age int)engine=myisan charset=gbk;  
5.查看表字段
    -格式：desc 表名；
    desc student;
6.删除表
    -格式：drop table 表名；
    drop table person;
</code></pre>

<h2>对已创建的表进行修改</h2>
<pre><code>1.修改表名
    -格式：rename table 原名 to 新名
     rename table t1 to t2;
2.修改表引擎和字符集
     -格式：alter table 表名 engine=myisam/innodb charset=utf8/gbk;
    alter table t2 engine=myisam charset=utf8;
3.添加表字段 
    -格式：alter table 表名 add 字段名 字段类型 (添加到最后)
         alter table t2 add age int;

        alter table 表名 add 字段名 字段类型 first(添加到最前面)
    alter table t2 add id int first;

    alter table 表名 add 字段名 字段类型 after XXX(在某个字段后面添加)    
        alter table t2 add sal int after name;
4.删除表字段
     -格式：alter table 表名 drop 字段名；
     alter table t2 drop sal;
5.修改表字段名和类型
     -格式：alter table 表名 change 原字段名 新字段名 新类型；
     alter table t2 change name username varchar(5);
6.修改表字段类型和位置
    -格式：alter table 表名 modify 字段名 新类型 first/after XXX ；
    alter table t2 modify age int after id;     
</code></pre>

<h2>数据相关SQL</h2>
<pre><code>    create database mydb1 character set utf8;
    use mydb1;ify
    create table hero(name varchar(10),age int);
1.插入数据
    -全表插入格式：insert into 表名 values(值1，值2);
                   insert into hero values('Tom',18);
                   insert into hero values('刘备',20);
    -指定字段插入格式：insert into 表名 (字段1,字段2）values(值1，值2); 
                   insert into hero (name) values ('李白');
    -批量插入：在以上两种格式后面写多组数据通过逗号分隔
                   insert into hero values('关羽',19),('张飞',17),('曹操',22); 
                       insert into hero (name) values('悟空'),('沙僧'),('八戒');
2.查询数据
    -格式：select 字段信息 from 表名 where 条件；
        1.查询所有数据，所有字段信息
             select * from hero;
        2.查询所有的名字
             select name from hero;
        3.查询年龄19岁的所有信息
             select age from hero where age=19;
        4.查询名字为刘备的年龄是多少
             select age from hero where name='刘备'; 
    3.修改数据
    -格式：update 表名 set age=30 where name='XXX';
             update hero set age=30 where name = '李白';
             update hero set age=25,name='悟能' where name='八戒';
            （注：如果不给条件则修改全表的数据！） 
    4.删除数据 
    -格式：delete from 表名 条件；
             delete from hero where age&lt;20;
             delete from hero; 
            （注：如果不给条件则删除全表的数据！） 
</code></pre>

<h2>                                   主键约束以及事物相关的内容</h2>
<hr />
<h4>主键约束</h4>
<pre><code>-什么是主键：表示每条数据唯一性的字段为主键
-什么是约束：约束是创建表时给字段添加的限制条件
-什么是主键约束：给主键添加的约束条件，可以保证主键的唯一性且非空 
-格式为： create table t1(id int primary key,name varchar(10));
     insert into t1 values(1,'tom');//通过
     insert into t1 values(1,'jerry');//报错，不能重复
     insert into t1 values(1,'lucy');//报错，不能为空
-主键约束+自增
    -格式为：
        create table t2(id int primary key auto_increment,name varchar(10));
            insert into t2 values(1,'tom');
            nsert into t2 values(null,'tom');//第一个参数需写null来触发自增
            insert into t2 values(null,'jerry');
     -自增规律：添加了自增后，主键值不能为0，自增数值只增不减，从历史最大值基础上+1
        insert into t2 values(100,'AAA');
        insert into t2 values(null,'BBB');

        delete from t2 where id&gt;=100;
        insert into t2 values(null,'CCC');//id为102
</code></pre>

<h2>注释 comment</h2>
<pre><code>-用于对表的字段进行描述
-格式为：
    create table t3(id int primary key auto_increment comment '这是主键',
        name varchar(10) comment '这是名字');
</code></pre>

<h2>`和'</h2>
<pre><code>- ``:用于修饰表名和字段名，可加可不加
        create table `t4`(name varchar(10));
- '':用于修饰字符串 
</code></pre>

<h2>数据冗余</h2>
<pre><code>-主键:表示数据唯一性字段
-外键:用于建立两张表关系的字段
--&gt;由于表设计不够合理导致数据出现大量重复数据，这种现象称为数据冗余，通过拆分
   表的形式解决冗余问题。
---案例1：
        1.保存集团总部下教学研发部下java教学一部的苍老师一枚，工资2000
        年龄18岁，部门地点大钟寺
        2.保存集团总部下市场部下的刘备，工资800，年龄25，部门地点天安门
        3.人事部下的薪酬部的员工张飞，工资400 年龄18，部门地点八达岭

            1 创建员工表和部门表
                创建员工表---&gt;编号 姓名 年龄 工资 部门编号
                 create table t_emp(id int primary key auto_increment,name varchar(10),
                age int,sal int,deptid int);   
            创建部门表---&gt;编号 名字 地点 上级部门
                create table t_dept(id int primary key auto_increment,name varchar(10),
                loc varchar(10),parentid int);

            2 插入数据
                insert into t_dept values(null,'集团总部','北京',null),(null,'教研部','北京',1),
                (null,'java一部','大钟寺',2),(null,'市场部','天安门',1),(null,'人事部','北京',1),  
                (null,'薪酬部','八达岭',5); 

                insert into t_emp values(null,'苍老师',18,2000,3),(null,'刘备',25,800,4),(null,'张飞',18,400,6);

--案例2：
        1.保存家电分类下电视机分类下的夏普50寸液晶电视机，价格5000，库存25个
        2.保存办公耗材下的打印机分类下的惠普彩色打印机，价格3000，库存10个

        1创建分类表
                create table category(id int primary key auto_increment,name varchar(10),parentid int);
        创建商品表
            create table item(id int primary key auto_increment,name varchar(10),price int,num int,categoryid int);       

        2插入数据
            insert into category values(null,'惠普',null),(null,'夏普',null),(null,'夏普家电',2),(null,'惠普打印机',1);
            insert into item values(null,'50寸液晶电视机',5000,25,3),(null,'打印机',3000,10,4);
</code></pre>

<h2>事物</h2>
<pre><code>-什么是事物：事物是数据库中执行同意业务多条SQL语句的工作单元,可以保证多条SQL全部执行成功或者
                全部执行失败
        例--&gt;:
         1.创建table并添加数据
            create table user(id int primary key auto_increment,name varchar(10),money int,state varchar(5));
            insert into user values(null,'苍老师A',50,'正常'),(null,'苍老师B',0,'冻结'),(null,'刘老师',10000,'正常');
         2.向苍老师B转钱（冻结账户）
             刘老师-2000
            update user set money=money-2000 where id=3 and state='正常';
             苍老师B+2000
            update user set money=money+2000 where id=2 and state='正常';
        --代码一条成功一条失败，导致丢失2000R，可以通过事物解决该问题

     1.开启事物 begin;   
     2.执行转账
     3.如果全部成功执行提交事物 commit;
 4.如果部分成功执行回滚事物 rollback;

-保存回滚点 savepoint
    -格式： 
        savepoint 标识;
            rollback to 标识;
        例--&gt; :  
            begin;
        update user set money=10 where id=2;
        savepoint s1;
        update user set money=20 where id=2;
        savepoint s2;
        update user set money=30 where id=2;
        rollback to s1;//苍老师B money=10              
</code></pre>

<h2>                                      SQL分类 </h2>
<hr />
<h2>SQL分类</h2>
<pre><code>1.DDL Data Definition Language 数据定义语言
    -包括：create ,drop,alter,truncate
    truncate:删除表并创建新表，和delete清空表不同的是，自增数值会清0
        -不支持事物
2.DML Data Manipulation Language 数据操作语言
    -包括：insert,update,delete,select(DQL)
        -支持事物
3.DQL Data Query Language 数据查询语言
    -只包括：select
4.TCL Transaction Control Language 事物控制语言
    -包括：begin,commit,rollback to XXX,savepoint XXX
5.DCL Data Control Language 数据控制语言
        -分配权限
</code></pre>

<h2>                                      数据类型</h2>
<hr />
<h2>数据类型</h2>
<pre><code>1.整数
    -常用整数有int(m)和bigint(m),m代表显示长度，需要结合zerofill关键字使用
        create table t_int(id int,age int(10) zerofill);
        insert into t_int values(1,18);
        select * from t_int; //00000018
2.浮点数
    -double(m,d) m代表总长度，d代表小数长度
        如：76.323   m=5 d=3
    -decimal(m,d) m代表总长度，d代表小数长度,超高精度浮点数，需要涉及超高精度运算时使用
3.字符串
    -char(m)  固定长度，m=10,abc 所占长度为10，效率略高，最长255
    -varchar(m) 可变长度，m=10,abc 所占长度为3，最长65535，超过255建议使用text
    -text 可变长度，最大65535，通常保存大于255长度的文本 
4.日期
    -date 只保存年月日
    -time 只保存时分秒
    -datetime 保存年月日时分秒,最大值9999-12-31，默认值null
    -timestamp 保存年月日时分秒,最大值2038-01-19，默认值为当前系统时间
        --&gt;例：
            create table t_date(d1 date,d2 time,d3 datetime,d4 timestamp);
            insert into t_date values('2018-12-14',null,null,null); 
            insert into t_date values(null,'18:23:25','2018-12-14 18:23:25',null);
</code></pre>

<h2>                                      数据查询（重点）</h2>
<hr />
<h4>导入文件tables.sql到数据库中</h4>
<pre><code>1.windows系统
    把tables.sql文件保存到D盘根目录，在连接数据库后输入命令：source d:/tables.sql;
2.linux系统
    保存tables.sql文件在桌面，命令为：source /home/soft01/桌面/tables.sql; 
</code></pre>

<h2>is null 和is not null</h2>
<pre><code>1.查询奖金为null的所有员工信息
    select * from emp where comm is null;
        注：
        null不能用等号判断，得用is/is not
2.查询没有上级领导(mgr)的员工信息   
    select * from emp where MGR is null;
3.查询有奖金的员工姓名，工资，奖金
    select ename,sal,comm from emp where comm is not null and comm&gt;0;
</code></pre>

<h2>别名</h2>
<pre><code>-给表字段重新赋一个个人好理解的名字，仅显示时使用
    select ename as '姓名',sal as '工资'from emp;
    select ename '姓名',sal '工资' from emp;    
    select ename 姓名,sal 工资 from emp;
最后一种如果报错请输入：set names gbk;  
</code></pre>

<h2>去重</h2>
<pre><code>-查询员工表中所有出现的职位，不能重复
    select distinct job from emp;
</code></pre>

<h2>比较运算符&gt;,&lt;,&gt;=,&lt;=,=,!=和&lt;&gt;</h2>
<pre><code>1.查询工资小于1600的员工姓名和工资
    select ename,sal from emp where sal&lt;1600;
2.查询部门编号是20的员工姓名，职位，和工资
    select ename,job,sal from emp where deptno=20;
3.查询职位是manager的所有员工姓名和职位
    select ename,job from emp where job='manager';
4.查询部门编号deptno不是10的部门所有员工姓名和部门编号
    select ename,deptno from emp where deptno!=10;
    select ename,deptno from emp where deptno&lt;&gt;10;
</code></pre>

<h2>and 和 or</h2>
<pre><code>-and 和java中的&amp;等效
-or 和java中的||等效
    1.查询部门编号deptno为30或者上级领导mgr为7698的员工姓名，上级领导和部门编号
        select ename,mgr,deptno from emp where deptno=30 or mgr=7698; 
        select ename,mgr,deptno from emp where deptno=30 and mgr=7698;
    2.查询不是10号部门并且工资不低于3000的员工信息
        select * from emp where deptno!=10 and sal&gt;=3000;
    3.查询工资为5000，1500，3000的员工信息
        select * from emp where sal=5000 or sal=3000 or sal=1500;
</code></pre>

<h2>in关键字</h2>
<pre><code>-当查询字段中值为多个时使用in
    .查询工资(不)为5000，1500，3000的员工信息
        select * from emp where sal (not) in(5000,3000,1500);
</code></pre>

<h2>between x and y(包含x和y)</h2>
<pre><code>.查询工资在2000到4000之间(外)的员工信息
    1.select * from emp where sal&gt;=2000 and sal&lt;=4000;
    2.select * from emp where sal(not)between 2000 and 4000;
</code></pre>

<h2>模糊查询 (not)like</h2>
<pre><code>- _:代表单个未知字符
 %:代表0或者多个未知字符
    --&gt;例：
        a开头：a%   第二个字母是a：_a%    第二个字符是x倒数第三个字符是y：_x%y__
        包含a:%a%
1.查询名字中包含字母a的员工的姓名
    select ename from emp where ename like '%a%'; 
2.查询单价低于100的记事本
    select title from t_item where title like '%记事本%' and price&lt;100;                        
3.查询标题中包含记事本的商品标题
    select title from t_item where title like '%记事本%';
4.单价50-200之间得力商品信息
    select * from t_item where title like '%得力%' and price between 50 and 200;
5.有图片的得力商品
    select * from t_item where title like '%得力%' and image is not null;
6.有赠品的商品信息  
    select * from t_item where sell_point like '%赠%';
7.名字中不含a的员工  
    select ename from emp where ename not like '%a%';
</code></pre>

<h2>排序 order by</h2>
<pre><code>-默认为升序  可以通过asc和desc控制升序和降序
1.查询所有员工姓名和工资，按工资升序排序
    select ename,sal from emp order by sal;
    select ename,sal from emp order by sal desc;//降序
2.查询工资低于2000的员工姓名和工资，按照降序排列
    select ename,sal from emp where sal&lt;2000 order by sal desc;
3.查询所有员工的姓名，工资，部门编号，按照部门编号升序，工资升序(降序)排列     
    select ename,sal,deptno from emp order by deptno,sal (desc);
</code></pre>

<h2>分页查询 limit</h2>
<pre><code>-limit 跳过的条数，请求的条数(注：请求的条数即为每页的条数)
    --&gt;例：第八页的5条信息 limit 35,5     第六页的4条信息 limit 20,4 
1.查询员工表中第一页的5条数据
    select * from emp limit 0,5;
2.查询第二页的4条数据
    select * from emp limit 4,4;
3.查询第三页的2条数据
    select * from emp limit 4,2;    
4.查询工资最高的三个员工的姓名和工资
    select ename,sal from emp order by sal desc limit 0,3;
</code></pre>

<h2>组链接：group_concat(表字段1,'连接符',表字段2)</h2>
<pre><code>1.**面试题：查询员工表每个部门员工的姓名，每个部门名字的名字显示到一行
    select deptno,group_concat(ename) from emp group by deptno;     
2.查询员工表每个部门中每个员工的姓名和工资，要求每个部门的信息显示到一行
    select deptno,group_concat(ename,'-',sal) from emp group by deptno;
</code></pre>

<h2>数值计算+，-,*,/,7%2等效mod(7,2)</h2>
<pre><code>1.查询员工姓名，工资及年终奖(年终奖=工资*5)
    select ename,sal,sal*5 '年终奖' from emp; 
2.查询商品表中的商品单价，库存num和总金额(库存*单价)
    select price,num,price*num '总金额' from t_item;
</code></pre>

<h2>                                       SQL中的函数</h2>
<hr />
<h2>和日期相关的函数</h2>
<pre><code>-1.SQL语言的HelloWorld 
    select 'HelloWorld';
-2.获取当前日期+时间 now()
    select now();
-3.获取当前的日期/时间 current();
    select curdate()/curtime();
-4.从完整的年月日时分秒中获取年月日 和 获取时分秒
    select date(now()),time(now());
-5.从完整的年月日时分秒中提取事件分量 extract()
    extract(year/month/day/hour/minute/second from 表字段) 
            查询每个员工的入职时间
            select ename,extract(year from hiredate) '入职年份' from emp;

-6.日期格式化 date_format()
        -格式：date_format(时间,格式);
            %Y代表4位年 2018    %m代表2位月   05  %d代表日   %i代表分  %s代表秒
            %y代表2位年 18      %c代表1位月   5   %H代表24小时制  %h代表12小时制
            --&gt;例： 
                    -把now()得到的时间格式化转成 年月日时分秒格式
                    select date_format(now(),'%Y年%m月%d日 %H时%i分%s秒');

-7.把非标准时间格式化转回标准格式 str_to_date('非标准事件'，'格式') 
            --&gt;例：
                把14.10.2018 16:28:30 转回标准格式
            select str_to_date('14.10.2018 16:28:30','%d.%m.%Y %H:%i:%s');
</code></pre>

<h2>ifnull(x,y)</h2>
<pre><code>- age=ifnull(x,y)  即：如果x的值为null则age=y,否则age=x
    --&gt;例：
        1.修改员工表中如果现有奖金为null则修改为0否则不变
            update emp set comm=ifnull(comm,0);
</code></pre>

<h2>聚合函数</h2>
<pre><code>-用于对多行数据进行统计，平均值，最大，最小，求和，统计数量
    1.平均值：avg(字段名)
        --&gt;例：
                 查询30号部门的平均工资
                select avg(sal) from emp where deptno=30;
    2.最大值：max(字段名)
        --&gt;例：
                查询20号部门的最高工资
                select max(sal) from emp where deptno=20;
    3.最小值：min(字段名)
        --&gt;例：
                查询10号部门的最低工资
                select min(sal) from emp where deptno=10;
    4.求和：sum(字段名)
        --&gt;例：
                查询30号部门的奖金总和
            select sum(comm) 奖金总和 from emp where deptno=30;
    5.统计数量：count(字段名)大部分情况下括号直接写*就可以，有特殊查询要求(需要考虑是否有null值)的
              须写表字段
        --&gt;例：
                1.统计所有员工的数量
                select count(*) from emp;
                2.统计所有有上级的员工数量
                select count(mgr) from emp;
</code></pre>

<h2>字符串相关的函数</h2>
<pre><code>1.拼接 concat(s1,s2)
    select concat('aa','bb');//aabb
     --&gt;例：
            查询每个员工的姓名和工资，工资后面有单位美元
            select ename,concat(sal,'美元') from emp;
2.获取字符串长度 char_length(str)
    --&gt;例：
            查询每个员工的姓名和姓名的长度
            select ename,char_length(ename) from emp;
3.获取字符串A在字符串B中出现的位置(从1开始)  instr(str,substr)
        select instr('abcdef','a');
4.插入字符串 insert(str,start,length,newstr) 从第三个开始往后2个长度插入覆盖
        select insert('abcdefg',3,2,'m');//结果为 abemfg   
5.转换大小写 
        select upper('nba')/lower('NBa');
6.去两端空白
        select trim(' ab  ');//ab
7.截取字符串 substring(str,start,length)
        select substring('abcdefg',2);//bcdefg
        select substring('abcdefg',2,3);//bcd  
8.重复 repeat(str,count) count为重复的次数
        select repeat('ab',2);//abab
9.替换 
        select replace('abcdefg','c','mm');//abmmdefg
10.反转
        select reverse('abc');//cba
</code></pre>

<h2>分组统计查询 group by xxx</h2>
<pre><code>-格式：group by 表字段
1.查询每个部门的平均工资
    select deptno,avg(sal) from emp group by deptno; 
2.查询各种职业的最高工资
    select job,max(sal) from emp group by job;
3.查询每个部门的人数
    select deptno,count(*) from emp group by deptno;
4.查询每个分类的商品的平均价格
    select category_id,avg(price) from t_item group by category_id; 
5.查询每个主管的手下人数
    select ename,mgr,count(*) from emp where mgr is not null group by mgr;

-通过多个字段进行分组统计
        -格式：
        group by 表字段1，表字段2
            1.统计每个部门下每个主管的手下人数
                select deptno,mgr,count(*) from emp where mgr is not null group by deptno,mgr;
</code></pre>

<h2>having</h2>
<pre><code>-聚合函数条件不能写在where后面，where后面只能写普通字段条件
-having后面写聚合函数条件，虽然也可以写普通字段条件，但不推荐
-having要和分组查询结合使用
    关键字的顺序为：select...from 表名 where...group by...having...order by...limit...
1.查询平均工资大于2000的部门编号和平均工资
    select deptno,avg(sal) a from emp group by deptno having a&gt;2000;        
2.查询238和917两个分类的平均价格
    select category_id c,avg(price) from t_item where category_id in(238,917)
    group by c;
3.查询表中每个部门的平均工资高于2000的部门编号，部门人数，平均工资，然后
  按照平均工资降序排列            
    select deptno,count(*),avg(sal) from emp group by deptno having avg(sal)&gt;2000
    order by avg(sal);
4.查询emp表中工资在1000到3000之间的员工 ，每个部门的编号，工资总和，平均工资，过滤掉工资
  低于2000的部门，按照平均工资升序排列
    select deptno,sum(sal),avg(sal) from emp where sal between 1000 and 3000 group
    by deptno having avg(sal)&gt;=2000 order by avg(sal);          
5.查询emp表中不是以s开头，每个职位的名字，人数，工资总和，最高工资，过滤掉平均工资是3000的职位
  ，根据人数升序排列，如果人数一致则根据工资总和降序排列
    select job,count(*),sum(sal),max(sal) from emp where job not like 's%' group by
    job having avg(sal)!=3000 order by count(*),sum(sal) desc;  
6.查询每年入职的人数
    select extract(year from hiredate) e,count(*) from emp group by e;   
7.查询最高平均工资的部门编号
    select deptno,avg(sal)from emp group by deptno order by avg(sal) desc limit 0,1;
</code></pre>

<h2>子查询（嵌套查询）</h2>
<pre><code>-写在SQL语句中的查询语句成为子查询，可以嵌套无数层
-子查询可以写的位置：
    1.写在where和having的后面当作查询条件
    2.可以写在创建表的时候
        --&gt;例:
            create table emp_10 as(select * from emp where deptno=10); 
                将查询到的内容赋值给所创建的新表emp_10
    3.写在from的后面当成一张虚拟表（注：必须写别名！）
            --&gt;例:
            select ename from (select * from emp where deptno=10) nt;

1.查询员工表中工资最高的员工的信息
    select max(sal) from emp;
    select * from emp where sal=(select max(sal) from emp);
2.查询表中工资大于平均工资的所有员工信息
    select avg(sal) from emp;
    select * from emp where sal&gt;(select avg(sal) from emp);
3.查询工资高于20号部门最高工资的员工信息
    select max(sal) from emp where deptno=20;
    select * from emp where sal&gt;(select max(sal) from emp where deptno=20);
4.查询和jones相同工作的其他员工信息
    select job from emp where ename='jones';
    select * from emp where job=(select job from emp where ename='jones') and
    ename!='jones';
5.查询最低工资员工的一个部门的其他员工的信息
    select min(sal) from emp;//找到最低工资
    select ename from emp where sal=(select min(sal) from emp);//最低工资员工姓名
    select deptno from emp where sal=(select min(sal) from emp);//最低工资员工部门

    select * from emp where deptno=(select deptno from emp 
    where sal=(select min(sal) from emp)) 
    and ename!=(select ename from emp where sal=(select min(sal) from emp)); 
6.查询员工king的部门编号和部门名称（需要用到dept表）
    select deptno from emp where ename='king';
    select deptno,dname from dept where deptno=(select deptno from emp where ename='king');      
7.查询有员工的部门信息(去掉没有员工的部门)
    select distinct deptno from emp;
    select * from dept where deptno in(select distinct deptno from emp);
8.查询平均工资最高的部门信息(考虑有多个部门平均工资一样的情况)
    elect avg(sal) from emp group by deptno order by avg(sal) desc limit 0,1;//最高平均工资

    select deptno from emp group by deptno having avg(sal)=
    (select avg(sal) from emp group by deptno order by avg(sal) desc limit 0,1);//最高平均工资的部门编号

    select * from dept where deptno in (select deptno from emp group by deptno having avg(sal)=
    (select avg(sal) from emp group by deptno order by avg(sal) desc limit 0,1));//信息
</code></pre>

<h2>关联查询</h2>
<pre><code>-同时查询多张表的查询方式称为关联查询,关联查询必须给关联关系即条件，条件为多张表之间的相同表字段
-条件格式为：表名1.相同表字段=表名2.相同表字段
-查询方式有三种：
    1.等值连接：select * from A,B where A.x=B.x and age=yyy;
    2.内连接：select * from A join B on A.x=B.x where age=yyy;
    （注：前两种均为取交集数据！推荐使用内连接）
    3.外连接：select * from A left/right join B on A.x=B.x where age=yyy;   
    外联结分为左外和右外，得到的是一张表的全部数据及和另外一张表的交集数据）
1.查询每个员工的姓名和对应的部门名称
    select emp.ename,dept.dname from emp,dept where emp.deptno=dept.deptno;//等值连接
    select e.ename,d.dname from emp e join on dept d e.deptno=d.deptno;//内连接
2.查询king的姓名，工资，部门名称，工作地点
    select emp.ename,emp.sal,dept.dname,dept.loc from emp,dept where emp.deptno=
    dept.deptno and ename='king';
3.查询工资大于2000的员工姓名和工作地点
    select e.ename,d.loc
    from emp e join dept d
    on e.deptno=d.deptno where sal&gt;2000;
4.查询所有部门编号，名称和对应的员工姓名
    select d.deptno,d.dname,e.ename
    from emp e right join dept d
    on e.deptno=d.deptno;

-**特殊关联**：自关联查询  把一张表当成两张表，通过内连接或者外连接把两个表连接起来查询
        --&gt;例：
        1.查询员工信息和他的主管的姓名
            select e.*,m.ename
            from emp e left join emp m
            on e.mgr=m.empno;

        2.查询员工信息，员工主管名字，部门名
          (自关联后再与别的表相连，后面添加join...on...)
            select e.*,m.ename,d.dname
            from emp e left join emp m
            on e.mgr=m.empno
            join dept d
            on e.deptno=d.deptno;   
</code></pre>

<h2>笛卡尔积</h2>
<pre><code>-如果关联查询不写关联关系会得到两张表数据的乘积，称为笛卡尔积，工作中切记不能出现，会占用大量内存
</code></pre>

<p>直至崩溃！</p>
<h2>                                    表设计之关联关系</h2>
<hr />
<h2>一对一</h2>
<pre><code>-什么是一对一：有AB两张表，A表中一条数据对应B表中的一条数据 ，同时B表也对应A表的一条数据
，这两张表称为的关系称为一对一
-应用场景：用户表和用户信息扩展表，商品表和商品信息扩展表
-如何建立关系：在主表中添加主键，从表中添加外键指向主表的主键

--&gt;例：
    创建用户表user(id,username,password)和用户信息扩展表userinfo(userid,nick,qq)保存以下
        数据：
    libai  admin 诗仙 112233
    liubei admin 刘皇叔 558866
    diaochan 123456 貂蝉 554433
1.查询每个用户的用户名，昵称，qq
    select u.username,ui.nick,ui.qq
    from user u join userinfo ui
    on u.id=ui.userid;      
2.查询诗仙的用户名和密码
    select u.username,u.password
    from user u join userinfo ui
    on u.id=ui.userid where ui.nick='诗仙';
3.查询diaochan的所有信息
    select *
    from user u join userinfo ui
    on u.id=ui.userid where u.username='diaochan';
</code></pre>

<h2>一对多</h2>
<pre><code>-什么是一对多：
    有AB两张表，A表中一条数据对应B表中多条数据，同时B表中的一条数据对应A表中的一条
             数据
-应用场景：
    员工表和部门表，商品表和商品分类表
-如何建立关系：
    在多的表中创建外键指向另外一张表的主键

--&gt;例：
    创建员工表t_emp(id,name,deptid)和部门表t_dept(id,name)，保存以下数据：
    神仙部的猪八戒和孙悟空
    妖怪部的蜘蛛精和白骨精
1.创建
    1.创建2张表
        create table t_emp(id int primary key auto_increment,name varchar(10),deptid int)engine=myisam
        charset=gbk;
        create table t_dept(id int,name varchar(10))engine=myisam
        charset=gbk;
    2.插入数据
        insert into t_emp values(null,'猪八戒',1),(null,'悟空',1),(null,'蜘蛛精',2),(null,'白骨精',2);
        insert into t_dept values(1,'神仙部'),(2,'妖怪部');

2.查询
    1.查询每个部门对应的员工姓名
        select e.name,d.name
        from t_emp e join t_dept d
        on e.deptid=d.id;
2.查询猪八戒的部门名称
        select e.name,d.name
        from t_emp e join t_dept d
        on e.deptid=d.id where e.name='猪八戒';
3.查询妖怪部的员工姓名
        select e.name
        from t_emp e join t_dept d
        on e.deptid=d.id where d.name='妖怪部';
</code></pre>

<h2>多对多</h2>
<pre><code>-什么是多对多：
    有AB两张表，A表中一条数据对应B表中的多条数据，同时B表中一条数据对应A表中的多条
            数据，称为多对多
-应用场景：
    学生表和老师表  用户和角色表
-如何建立关系：
    创建一个关系表，在关系表中有两个外键分别指向两个表的主键

--&gt;例：
    创建学生表student(id,name)和老师表teacher(id,name)以及学生老师关系表,保存以下数据：
    苍老师：小明，小红，小黄
    传奇老师：小明，小绿

1.创建
    1.创建3张表
        create table student(id int primary key auto_increment,name varchar(10))engine=myisam
        charset=gbk; 

        create table teacher(id int primary key auto_increment,name varchar(10))engine=myisam
        charset=gbk;

        create table s_t(sid int,tid int )engine=myisam charset=gbk; 

    2.插入数据
        insert into student values(null,'小明'),(null,'小红'),(null,'小黄'),(null,'小绿');      
        insert into teacher values(null,'苍老师'),(null,'传奇老师');
        insert into s_t values(1,1),(1,2),(2,1),(3,1),(4,2);
2.查询
    1.查询每个老师姓名和对应的学生的姓名
        select t.name,s.name
        from s_t st join student s
        on st.sid=s.id join teacher t
        on st.tid=t.id;
    2.查询苍老师的学生都有谁
        select s.name,t.name
        from s_t st join student s
        on st.sid=s.id join teacher t
        on st.tid=t.id where t.name='苍老师';
3.查询小明的老师都有谁    
        select s.name,t.name
        from s_t st join student s
        on st.sid=s.id join teacher t
        on st.tid=t.id where s.name='小明';
</code></pre>

<h2>表设计案例：权限管理</h2>
<pre><code>总共的表数:  
    -三张主表：用户表 角色表 权限表
    -两张关系表：用户角色关系表 角色权限关系表
    1.创建表：
        user(id,name) ,role(id,name) ,module(id,name) ,u_r(uid,rid) ,r_m(rid,mid)
        create table user(id int primary key auto_increment,name varchar(10));
        create table role(id int primary key auto_increment,name varchar(10));
        create table module(id int primary key auto_increment,name varchar(10));
        create table u_r(uid int,rid int);
        create table r_m(rid int,mid int);

    2.保存数据：
        1.主表
            insert into user values(null,'苍老师'),(null,'小明'),(null,'克晶老师');
            insert into role values(null,'男游客'),(null,'男管理员'),(null,'女会员'),
            (null,'女管理员');
            insert into module values(null,'男浏览'),(null,'男发帖'),(null,'男删帖'),
            (null,'女浏览'),(null,'女发帖'),(null,'女删帖');
        2.关系表
            insert into u_r values(1,2),(1,4),(2,3),(3,4),(3,1);
            insert into r_m values(1,1),(2,1),(2,2),(2,3),(3,4),(3,5),(4,4),(4,5),(4,6);

    3.查询
             1.查询每个用户对应的所有权限
            select user.name 用户,module.name 权限
            from u_r join user
            on user.id=u_r.uid join role
            on role.id=u_r.rid join r_m
            on r_m.rid=role.id join module
            on module.id=r_m.mid order by user.name;
             2.查询苍老师的权限都有那些
            select module.name
            from u_r join user
            on user.id=u_r.uid join role
            on role.id=u_r.rid join r_m
            on r_m.rid=role.id join module
            on module.id=r_m.mid where user.name='苍老师';
             3.查询有男浏览权限的都有那些人
            select user.name
            from u_r join user
            on user.id=u_r.uid join role
            on role.id=u_r.rid join r_m
            on r_m.rid=role.id join module
            on module.id=r_m.mid where module.name='男浏览';   
</code></pre>

<h5>面试题(小薇收红包)</h5>
<pre><code>1.创建表
    1.交易流水表:交易号，交易时间，交易金额，交易类型，人物id
        create table trade(id int primary key auto_increment,time date,money int,
        type varchar(10),person_id int);
    2.人物表：id,姓名，性别，关系
        create table person(id int primary key auto_increment,name varchar(10),gender 
        varchar(10),rel varchar(10));
2.插入数据
    insert into person values(null,'刘德华','男','亲戚'),(null,'默克尔','女','亲戚'),
    (null,'马云','男','同事'),(null,'特朗普','男','朋友'),(null,'貂蝉','女','朋友');

    insert into trade values(null,'2018-04-20',-20,'微信',1),(null,'2018-05-15',500,'现金',2),
    (null,'2018-05-15',-50,'现金',2),(null,'2018-05-20',20000,'支付宝',3),
    (null,'2018-05-20',-20,'微信',3),(null,'2018-04-22',20000,'微信',4),(null,'2018-03-14',-20000,'微信',5);

3.统计从2018年2月15日至今所有红包的收益
    select sum(money) from trade where time&gt;str_to_date('2018年2月15号','%Y年%c月%d号');

4.统计2018年2月15日至今，金额大于100 所有女性亲戚的名字和金额
    select
    from trade t join person p
    on t.person_id=p.id
    where t.money between;
</code></pre>

<h2>                                         视图相关</h2>
<hr />
<h2>视图</h2>
<pre><code>-什么是视图：
        视图和表都是数据库中的对象，视图可以理解成一张虚拟的表，视图本质就是取代了一段SQL
            查询语句
-作用：
    1.可以起到SQL语句重用的作用
    2.可以隐藏敏感信息
-创建视图的格式：
    create view 视图名 as (子查询)；//创建了一个虚拟的表
    create table 表名 as (子查询)；//创建了一个真实存在的表
    1.创建一个10号部门的视图
        create view v_emp_10 as (select * from emp where deptno=10);    
    2.创建一个20号部门并且工资小于2000的视图
        create view v_emp_20 as (select * from emp where deptno=20 and sal&lt;2000);
    3.创建一个没有工资的员工表的视图
        create view v_emp_nosal as(select empno,ename,job,mgr,hiredate,comm
        ,deptno from emp);//隐藏了工资
    4.创建每个部门平均工资，最高工资，最低工资，工资总和，部门人数的视图
        create view v_emp_h as(select avg(sal),max(sal),min(sal),sum(sal),count(*)
        from emp group by deptno);
</code></pre>

<h2>视图的分类</h2>
<pre><code>1.简单视图:
    创建视图的子查询中不包含，去重，函数，分组，关联查询的视图称为简单视图，可以对视图
    中的数据进行增删改查操作
2.复杂视图:
    和简单视图相反，只能查询

-对简单视图进行增删改操作：
    1.插入数据
        insert into v_emp_10 (empno,ename,sal,deptno) values (10010,'张三',888,10);
        select * from v_emp_10;//视图和原图都可见

        -往视图中插入一条部门编号为20号的数据
            insert into v_emp_10 (empno,ename,sal,deptno) values (10010,'李四',888,20);
            select * from v_emp_10;//视图中没有，原图中存在 

             **往视图中插入一条视图中不可见但是原表中可见的数据，称为数据污染，可以通过with check option
        关键字解决数据污染问题
            create view v_emp_30 as (select * from emp where deptno=30) with check option;
            insert into v_emp_30 (empno,ename,sal,deptno) values (10010,'李四',888,30);//成功
            insert into v_emp_30 (empno,ename,sal,deptno) values (10010,'李四',888,20);//失败

    2.修改数据(只能修改视图中存在的数据)
        update v_emp_10 set comm=comm+1;//成功
        update v_emp_10 set sal=1000 where deptno=20;//失败

    3.删除数据(只能删除视图中存在的数据)
        delete from v_emp_10 where ename='张三';//成功
        delete from v_emp_10 where ename='frod';//失败
</code></pre>

<h2>视图别名</h2>
<pre><code>-如果创建视图时子查询使用了别名，则后期对视图进行操作时也只能使用别名
    create view v_emp_name as (select ename name,sal from emp); 
    select * from v_emp_name where name='王武';//成功
    select * from v_emp_name where ename='王武';//失败
</code></pre>

<h2>                                          约束</h2>
<hr />
<h2>约束</h2>
<pre><code>-什么是约束：约束是给表字段添加的限制条件
    1.非空约束 not null：字段不能为空
        create table t1(id int,age int not null);

        insert into t1 values(1,20);// 成功
        insert into t1 values(1,null);// 失败
    2.唯一约束 unique：字段不能重复            
        create table t2(id int,age int unique);

        insert into t2 values(1,20);// 成功
        insert into t2 values(1,20);// 失败,数据重复
    3.默认约束 default:给字段设置默认值
        create table t3(id int,age int default 20);

        insert into t3 (id) values(1);//默认值生效
        insert into t3 values(2,18);//默认值无效
        insert into t3 values(3,null);//默认值无效，age值为null 
    4.主键约束：唯一且非空
    5.外键约束：添加外键约束的字段，值可以为null，可以重复，但是不能是关联表中不存在的数据
           ，被关联的数据不能先删除掉
-如何使用外键约束
        create database db7 character set utf8;
    1.创建部门表
        create table dept (id int primary key auto_increment,name varchar(10));

    2.创建员工表
        create table emp (id int primary key auto_increment,name varchar(10),
        dept_id int,constraint fk_dept foreign key (dept_id) references dept(id));

-格式介绍：
    constraint 约束名 foreign key(外键字段名) references 关联的表名（关联的字段名）
-测试：
    insert into dept values (null,'神仙'),(null,'妖怪');

    insert into emp values (null,'悟空',1);//成功
    insert into emp values (null,'艾亚人',3);//失败
    insert into emp values (null,'艾亚人',null);//成功
    delete from dept where id=1;//失败 有数据指向神仙

    delete from emp where id=1;//成功 删掉悟空
    delete from dept where id=1;//成功 没有数据指向神仙

-删除外键约束的方式：
    alter table emp drop foreign key fk_dept（约束名）;
-删除主键约束：
    alter table 表名 drop primary key;(主键不能带自增)
-测试： create table t1(ia int primary key); 
        alter table t1 drop primary key;    //成功        

        create table t1(ia int primary key auto_increment); 
        alter table t1 drop primary key;//失败，主键带自增
</code></pre>

<h2>                                       索引</h2>
<hr />
<h2>索引</h2>
<pre><code>1.什么是索引：
    索引是数据库中用于提高查询效率的技术，类似于目录
2.作用：
    如果不使用索引，数据会零散的保存在磁盘中，查询数据需要一个个遍历磁盘块，知道找到
    数据位置，使用索引后会将磁盘块以树状结构进行保存，查询数据会大大降低磁盘块的访问量，
    从而提升查询效率
3.索引是越多越好吗？
    不是，因为索引会占用存储空间，只针对常用的查询字段创建索引
4.索引是必须创建的吗？
    如果数据量很大，需要创建索引来提高查询效率；如果数据量不大，无需创建索引
     -测试：
        1.查询title='100'的数据(耗时0.89s)
        select * from item2 where title='100';//无索引
5.如何创建索引？
        -格式：
        create index 索引名 on 表名（字段名（字段长度））;
            create index i_item_title on item2(title);//有索引
        -测试: 
        select * from item2 where title='100';(耗时0.02s)
6.索引分类
        1.聚集索引：
        给表添加主键约束的时候，数据库会自动通过主键创建索引，称为聚集索引，
            聚集索引的磁盘块中保存数据
        2.非聚集索引：
        通过其他字段创建的索引称为非聚集索引，非聚集索引的磁盘块中只保留磁盘块
            的地址没有数据
7.如何查看索引？
        -格式：
        show index from 表名;
        show index from item2;

8.如何删除索引
        -格式：
        drop index 索引名 on 表名
        drop index i_item_title on item2;       

9.复合索引：通过多个字段创建的索引
        -格式：
        create index 索引名 on 表名(字段1，字段2);
        create index i_item_title_price on item2(title,price);
</code></pre>

<h2>                                         事物相关</h2>
<hr />
<h2>事物</h2>
<pre><code>1.事物：
    数据库中执行同一业务多亿奥SQL语句的工作单元，可以保证全部执行成功，或全部执行失败
2.事物的ACID特性：
    是保证事物执行的四大基本要素
        -Atomicity:原子性，最小不可拆分，保证全部成功或者全部失败
         -Consistency：一致性，从一个一致状态到另一个一致状态
        -Isolation：隔离性，多个事物之间互不影响
        -Durability：持久性，事物完成后数据提交到数据库中持久保存生效    
3.事物相关的指令：
        -begin:开启事物
        -commit:提交事物
        -rollback:回滚事物
        -savepoint xxx:保存回滚
        -rollback to xxx:回滚到指定事物点
     -查看数据库自动提交状态：
        show variables like '%autocommit%';
    -修改自动提交状态 0关闭 1开启
        set autocommit=0/1;
</code></pre>

<p>****面试题1</p>
<pre><code>有学生成绩表student,字段有id主键，name,subject学科,score成绩，保存以下数据：
    张三 语文 66，张三 数学 77，张三 英语 55，张三 体育 77
    李四 语文 59，张三 数学 88，张三 英语 78，张三 体育 95
    王五 语文 75，张三 数学 54，张三 英语 98，张三 体育 88

1.创建表
    create table student(id int primary key auto_increment,name varchar(10),
    subject varchar(10),score int);
2.插入数据
    insert into student values(null,'张三','语文',66),(null,'张三','数学',77),(null,'张三','英语',55),(null,'张三','体育',77),
    (null,'李四','语文',59),(null,'李四','数学',88),(null,'李四','英语',78),(null,'李四','体育',95),
    (null,'王五','语文',75),(null,'王五','数学',54),(null,'王五','英语',98),(null,'王五','体育',88);
3.查询    
    1.查询每个人的平均分降序排列
        select name,avg(score) from student group by name order by avg(score) desc;
    2.查询每个人的名字，以及这个人的科目和成绩 要求一行显示
        select name,group_concat(subject,'-',score) from student group by name;
    3.查询每个人的最高分和最低分
        select name, max(score),min(score) from student group by name;
    4.查询每个人不及格的科目及分数，不及格的科目数量
        select name 姓名,group_concat(subject,'-',score) 学科,count(*) 学科数 from student where score&lt;60 group by name;
</code></pre>


</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
